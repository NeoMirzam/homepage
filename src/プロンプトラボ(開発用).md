【汎用使い Cursor プロンプト】

> ⭐︎ 脳死実装マンになっていないか？本当に重要なのは機能や技術に対する本質的な仕組みを深く理解し、全体感や設計/実装方針がイメージとして明確化できていることだぞ。もし明確化つまり言語化が不足しているのであれば、必ずリサーチモードで知識のインプットから始めよ。
> ⭐︎ 開発なんてゴールが明確で、そこに至るのにどのような手段が必要で現時点では何が足りていないのか？機能実現というゴールを達成するにはどのような戦略が最適なのか？を突き詰めて考えるゲームである。機能要望がありビジョンが存在するものは必ず実装することができることを前提とすること。
> ⭐︎Cursor ウィンドウ複数開いてパラレル開発できているか？→ cmd + shift + n⭐︎
> ⭐︎solomon-command-rules がシンボリックされているか？
> [scur]プロジェクトルールコマンド:$solomon を必ず実行し、このメッセージにシンボリックした{{依頼内容}}をステップバイステップで段階的に理解し、熟考して、100 点満点の精度を担保して正確かつ完璧に実行して下さい。
> [refa]必ずあなたが今回新たに実装/修正した範囲に限定して、よりシンプルかつエレガントで、このプロジェクトの他の階層の既存実装の実装方針やコーディングスタイルを必ず模倣して、ステップバイステップで段階的に熟考して、リファクタリングを行って下さい。

@フィードバック修正依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

このメッセージにシンボリックしたファイルの実装に関して{{フィードバック}}:
"""

1. あなたが上記の会話中で実装したコードでは、なぜか Chrome ブラウザのプラグインによって表示される色が変化してしまうため、いかなるブラウザの拡張機能にも影響されない設定としてください。
   """
   の内容を正確に把握し、完璧に理解した上で、最適な修正後のコードをステップバイステップで考えて、出力してください。

---

@フィードバック&既存実装適合修正依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

このメッセージにシンボリックしたファイルの実装に関して{{フィードバック}}:
"""

- 今回あなたが上記で実装した`Message.tsx`の修正は不要だったことが判明したため、`Message.tsx`は既存コードのままという前提で、不要なコードを分析/整理して、削除しなさい。
  """
  の内容を正確に把握し、完璧に理解した上で、以下{{既存実装}}の内容を必ず参考にして、{{既存実装}}のコード構造や実装方針に倣って、最適な修正後のコードをステップバイステップで考えて、出力してください。

{{既存実装}}:
"""

- （例）"apps/frontend/src/layouts/base-layout/base-layout-recipe.ts"
- "apps/frontend/src/layouts/base-layout/components/header/header-recipe.ts"
  """

---

@フィードバック in 全体像把握ステップ修正依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが上記のやり取りで修正/実装した UI に対する項目追加は完璧だったので完了とします。ただ、追加した項目に対応するデータが表示されない問題が発生しており、取引先詳細画面に対応するレスポンスを確認したところ、{{JSON}}:

```

```

の通りになっており、今回新たに追加した項目のデータがバックエンド API から返ってきていないようです。
そのためあなたは、以下{{ステップ}}に分けて 100%の精度で完璧に仕様を満たしたコードの修正/実装を行いなさい。

{{ステップ}}:
'''

1. まず取引先詳細画面において、バックエンド側 API からどのようにフロント側 UI にレスポンスパラメータが連携されているか全体的な処理フローと順序を把握し、完璧に理解する

2. 1 で把握した全体的な処理フローと問題の原因、修正方針をステップバイステップで段階的に熟考して、私に対して超高品質なレポート形式で報告する

3. 2 で熟考した修正方針を元にして修正の実装を進める

4. 3 で修正した実装内容が、他機能への悪影響や既存実装との間に 100%の整合性が担保されていること、そして超高品質なコードソリューションとなっていることの 2 点を必ず検証して、2 点ともパスしていることを報告する。

5. 3 で実際に修正した内容について全てのコードに言及して、実装内容に期待される効果を明確に説明する。
   '''

---

@エラー解消
{{依頼内容}}:
"""
{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなた上記の実装を行ったことで、このメッセージにシンボリックしたコードで{{エラー}:
"""

"""
が発生しています。そのためあなたはこの{{エラー}}を解消するために、既存コードの構造や実装を必ず参考にして、ステップバイステップで考えて、エラー修正後のコードを出力してください。

---

@CI エラー解消依頼
{{依頼内容}}:
"""
{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

このメッセージにシンボリックした部分のコードを実装したことで、次の{{CI エラー}:
"""

"""
が発生しています。おそらくあなたが実装したコードだけでは不十分となっているため、

## {{CIエラー}}の内容を 100%正確に把握して、完璧に理解した上で{{CIエラー}}を解消するために、既存コードの構造や実装を必ず参考にして、ステップバイステップで考えて、修正後のコードを反映してください。修正が完了したらレビュー内容や他のコードとの整合性が 100%担保されてかについても、チェックを行なって高品質なコードが実装されたことを確認して報告しなさい。

@Rspec ユニットテスト実装依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになるｓ。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたはこのメッセージにシンボリックした rspec ファイルに対して、今回この作業ブランチで新たに追加した{{項目}}:

```

property :transaction_start_from_date, :string
property :transaction_start_to_date, :string
property :transaction_end_from_date, :string
property :transaction_end_to_date, :string

```

に対して、プロジェクトのユニットテスト方針(llms-full.txt を参照)に従って、最適な rspec テストコードを実装する必要があります。

そのためあなたは次の{{Rspecユニットテスト作成ルール}}:
'''

1. 既存のユニットテストコードは何が何でも絶対に変更してはなりません。
2. ユニットテストコードを実装する上で、私が過去に実装した以下{{例示コード}}とそれに対応する既存の見本となる{{Rspecユニットテストコード}}の 2 つを必ず参照した上で、この実装イメージに従って、新たに追加するユニットテストコードの実装方針やコード構造および処理手順を完璧に理解して、模倣するようにしなさい。
3. 今回の依頼で新しく追加するユニットテストコードは必ずファイルの最後の行に追加しなさい。
   '''
   を死守した上で、ステップバイステップで段階的に熟考して、100%の精度で完璧に仕様を満たしたユニットテストコードの実装を行なってください。{{ユニットテスト作成ルール}}にも記載しましたが、既存のユニットテストコードについては絶対に変更や削除をしてはいけません。そして新たなユニットテストの追加は、

{{例示コード}}:

```

property :transaction_start_date, :string
property :transaction_end_date, :string

```

{{例示ユニットテストコード}}:

```

transaction_start_date: '2021-01-01',
transaction_end_date: '2021-12-31',

expect(subject.transaction_start_date.strftime('%Y-%m-%d')).to eq(params[:transaction_start_date])
expect(subject.transaction_end_date.strftime('%Y-%m-%d')).to eq(params[:transaction_end_date])

```

---

@修正/実装内容解説依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回修正した{{テストコードA}}:

```

```

## について、全てのコードに漏れなく言及して、処理内容が誰でも理解できるようにステップバイステップで段階的に明快に解説してください。そして、{{テストコードA}}の修正/実装による他機能への影響や既存実装との間に 100%の整合性が担保されていることについても最終チェックを行うことで超高品質なコードソリューションとなっていることを確認して、レポート形式で報告して下さい。

@修正/実装内容質問依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回修正した{{テストコードA}}:

```

```

## における差異を全て検出して、その違いや実装意図をステップバイステップで段階的に熟考して、解説しなさい。

@不具合解消
{{依頼内容}}:
"""
あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが上記の実装を行なったことで、次の{{不具合}}:
'''

'''
が発生しています。そのためあなたはこの{{不具合}}を解消するために、既存コードの構造や実装を必ず参考にして、ステップバイステップで考えて、エラー修正後のコードを出力してください。
"""

## @動作確認依頼:

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回実装/修正したコードが 100%正確かつ完璧に仕様を満たしているかどうかを判断するために、{{手順}}:
"""

1. 国税書類の作成・更新 API 用の API キーを発行
   → rake td:create_tax_document_create_update_api_key[<user_id>]

2. 修正した部分に紐づく API を実行する
   {{例示}}:
   '''
   必須の項目は仕様書を参照のこと。

執筆時点で必須なのは`mimetype`と`original_filename`

```bash
curl https://bt-saml.secure.keihi.com/api/v2/td/tax_documents.json \cuments.json \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer <APIキー>' \
  --data-raw '{
    "mimetype": "image/png",
    "original_filename": "some_document_001.png"
    "name": "書類名",
	  "amount_include_tax": "1000",
    "memo": "メモ",
  }'
```

【取引先詳細 GET リクエスト-】

```bash
curl -X GET "http://localhost:3000/api/v2/kernels/suppliers?supplier_code=code-9&supplier_name=取引先-9" \
  -H "Authorization: Bearer Nqmd31W8lvvDB9lqWNFAIw" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json"
```

'''
"""
を必ず参考にして、このファイルにシンボリックされた部分のコードが正しく機能しているかステップバイステップで段階的に熟考して、検証して下さい。

---

## {{依頼内容}}:

以下の curl リクエストをポストマンで実行できるような形式で示して

curl -X GET "http://localhost:3000/api/v2/kernels/suppliers?supplier_code=code-9&supplier_name=取引先-9" \
 -H "Authorization: Bearer Nqmd31W8lvvDB9lqWNFAIw" \
 -H "Content-Type: application/json" \
 -H "Accept: application/json"

---

@プルリクエストレビュー修正依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回実装/修正したこのメッセージにシンボリックしたファイルについては、このプロジェクトに関わる他のメンバーから次の{{レビュー}}:
"""

1.

2.

3. """
   を受けました。そのためあなたは、メンバーの{{レビュー}}内容を 100%正確に把握して、完璧に理解した上で、最適な修正後のコードをステップバイステップで考えて、出力してください。ただし 2 と 3 に関しては、質問されているだけのため、最適な回答をステップバイステップで段階的に熟考して、出力して下さい。

---

@コミットメッセージ考案依頼
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回現在の作業ブランチで実装/修正した各ファイルについて、100 点満点の最適な粒度でコミットするための、コミットメッセージをファイル単位でステップバイステップで段階的に熟考して、それぞれ出力して下さい。なおコミットメッセージの記述形式については以下{{例示フォーマット}}を必ず参照して模倣すること

ただし、コミットメッセージを考えるにあたり、この作業ブランチで変更した箇所を`git diff`や`git log`コマンドなどの駆使して 100%正確にコミット履歴を読み取るようにしてください。

{{例示フォーマット}}:
"""

- add: TD 入力スキャン保管代行設定をユーザー設定に追加
- add: TD 入力スキャン保管代行設定プロパティの追加
- fix: 取引先詳細で送付先住所を表示制御するよう修正
- fix: 取引先編集で送付先住所を表示制御するよう修正
- fix: 送付先住所の表示有無による UI 切り替え修正
- fix: メールテンプレートの送付先住所表示を条件分岐
  """

---

@PR サマリー作成依頼
{{参考プルリクエスト}}:"https://github.com/TOKIUM/keihi/pull/29020"
{{依頼内容}}:

---

{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが今回現在の作業ブランチで実装/修正したこのメッセージにシンボリックした各ファイルについて、
プルリクエストのサマリーに記載する説明文をステップバイステップで段階的に熟考して、作成してください。
ただし、サマリーに記載する対象はこの作業ブランチで変更した箇所のみに限定されるため、`git diff`や`git log`コマンドなどを駆使して 100%正確にコミット履歴を読み取るようにしてください。

---

@チケットタスク実装依頼
{{依頼内容}}:

---

<task_context>
{{前提情報}}:
"""
ChatGPT/Wikipedia スタイル参照ツールチップ機能の実装方針

1. 要件整理
   現状と目標
   現状: ファイル検索結果が JSON として出力され、そのままユーザーに表示されている
   目標: ChatGPT や Wikipedia のように、参照タグをホバーするとツールチップが表示され、クリックすると参照元 URL にアクセスできる機能の実装
   具体的な要件
   instructor で JSON 形式で構造化データを出力させる
   フロントエンド側で JSON 形式を処理し、ユーザーには整形されたテキストのみを表示
   テキスト内の参照タグ（例: [1]）をホバーすると、参照元サイトのサマリーをツールチップで表示
   参照タグをクリックすると、参照元 URL に遷移する
2. 技術選定
   バックエンド側
   Instructor.js: LLM の出力を構造化 JSON として取得するためのライブラリ
   Zod: スキーマ定義とバリデーションに使用
   フロントエンド側
   Park UI/Radix UI: プロジェクトですでに使用されている UI ライブラリでツールチップ実装
   PandaCSS: スタイリングに使用（プロジェクトで既に採用）
   React: コンポーネントベースの実装
   """

{{実装方針}}:
""" 3. データ構造設計

```typescript
// 正しいJSON構造例
{
  "sections": [
    {
      "text": "この技術は注目されています[1]。また、さらに発展しています[2]。",
      "sources": [
        { "id": 1, "url": "https://example.com/article1", "title": "Article One", "summary": "この記事は...について説明しています" },
        { "id": 2, "url": "https://example.com/article2", "title": "Article Two", "summary": "この記事では...について詳しく解説しています" }
      ]
    },
    {
      "text": "今後の発展には、技術の進歩が必要不可欠です[1][2]。",
      "sources": [
        { "id": 1, "url": "https://example.com/article3", "title": "Article Three", "summary": "技術進歩の重要性について述べた記事" },
        { "id": 2, "url": "https://example.com/article4", "title": "Article Four", "summary": "将来の技術展望について分析した記事" }
      ]
    }
  ]
}
```

4.バックエンド側の実装:

```
import { Instructor } from '@instructor-js/instructor';
import { OpenAI } from 'openai';
import { z } from 'zod';

// OpenAIクライアントの初期化
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Instructorクライアントの設定
const client = Instructor({
  client: openai,
  mode: "FUNCTIONS",
});

// Zodスキーマ定義
const SourceSchema = z.object({
  id: z.number(),
  url: z.string().url(),
  title: z.string(),
  summary: z.string().optional()
});

const SectionSchema = z.object({
  text: z.string(),
  sources: z.array(SourceSchema)
});

const ResponseSchema = z.object({
  sections: z.array(SectionSchema)
});
```

5.構造化レスポンスの取得:

```
async function getStructuredResponse(prompt: string) {
  try {
    const response = await client.chat.completions.create({
      model: "gpt-4-0125-preview",
      response_model: ResponseSchema,
      messages: [
        {
          role: "system",
          content: `あなたは検索結果に基づいて回答を生成するアシスタントです。
回答には必ず参照情報を含めてください。参照情報は[1]のような形式で本文中に記載し、
対応するソース情報をsourcesフィールドに含めてください。
各セクションには、テキストと対応する参照情報のリストを含めてください。`,
        },
        { role: "user", content: prompt },
      ],
    });

    return response;
  } catch (error) {
    console.error("Error getting structured response:", error);
    throw error;
  }
}
```

6.フロントエンド側の実装:

```
import { Tooltip } from '@park-ui/react';

interface CitationTagProps {
  sourceId: number;
  sources: Source[];
}

const CitationTag: React.FC<CitationTagProps> = ({ sourceId, sources }) => {
  const source = sources.find(s => s.id === sourceId);

  if (!source) return <>[{sourceId}]</>;

  return (
    <Tooltip.Root>
      <Tooltip.Trigger asChild>
        <a
          href={source.url}
          target="_blank"
          rel="noopener noreferrer"
          className="citation-link"
        >
          [{sourceId}]
        </a>
      </Tooltip.Trigger>
      <Tooltip.Positioner>
        <Tooltip.Content>
          <div className="citation-tooltip">
            <h4 className="citation-title">{source.title}</h4>
            {source.summary && <p className="citation-summary">{source.summary}</p>}
            <span className="citation-url">{source.url}</span>
          </div>
        </Tooltip.Content>
      </Tooltip.Positioner>
    </Tooltip.Root>
  );
};
```

7.テキスト処理ロジック

```
// テキスト内の参照タグを検出し、コンポーネントに置き換える
const processText = (text: string, sources: Source[]): React.ReactNode[] => {
  // [数字] のパターンを検出する正規表現
  const regex = /\[(\d+)\]/g;

  // テキストをパーツに分割し、参照タグをコンポーネントに置き換える
  const parts: React.ReactNode[] = [];
  let lastIndex = 0;
  let match;

  while ((match = regex.exec(text)) !== null) {
    // タグの前のテキストを追加
    if (match.index > lastIndex) {
      parts.push(text.substring(lastIndex, match.index));
    }

    // 参照タグをコンポーネントに置き換え
    const sourceId = parseInt(match[1], 10);
    parts.push(
      <CitationTag
        key={`citation-${match.index}`}
        sourceId={sourceId}
        sources={sources}
      />
    );

    lastIndex = regex.lastIndex;
  }

  // 残りのテキストを追加
  if (lastIndex < text.length) {
    parts.push(text.substring(lastIndex));
  }

  return parts;
};
```

8.チャットメッセージ表示コンポーネント:

```
import React from 'react';
import { StructuredResponse } from '../types';
import { CitationTag } from './CitationTag';

interface ChatMessageProps {
  message: string | StructuredResponse;
  isUser: boolean;
}

export const ChatMessage: React.FC<ChatMessageProps> = ({ message, isUser }) => {
  // ユーザーメッセージの場合はそのまま表示
  if (isUser) {
    return <div className="user-message">{message as string}</div>;
  }

  // 文字列の場合はそのまま表示（エラーメッセージなど）
  if (typeof message === 'string') {
    return <div className="ai-message">{message}</div>;
  }

  // AIの構造化されたレスポンスを処理
  const structuredMessage = message as StructuredResponse;
  return (
    <div className="ai-message">
      {structuredMessage.sections.map((section, sectionIndex) => {
        // テキスト内の参照タグを検出して処理
        const processedText = processText(section.text, section.sources);

        return (
          <div key={`section-${sectionIndex}`} className="message-section">
            {processedText}
          </div>
        );
      })}
    </div>
  );
};
```

5. 実装時の考慮点:
   '''
   パフォーマンス
   多数の参照タグがある場合のレンダリングパフォーマンスに注意
   必要に応じてツールチップの遅延読み込みを検討
   アクセシビリティ
   キーボードナビゲーション対応
   スクリーンリーダー対応
   適切な ARIA タグの使用
   UX 向上
   ホバー時の視覚的フィードバックを工夫
   モバイル対応（タップ操作）の考慮
   クリック挙動のカスタマイズオプション提供
   エラーハンドリング
   JSON パースエラーへの対応
   参照タグと実際のソースの不一致への対応
   無効な URL への対応
6. 導入ステップ
   必要なパッケージのインストール
   Instructor.js, Zod, 選択したツールチップライブラリ
   バックエンド側の実装
   スキーマ定義と Instructor.js の設定
   LLM プロンプトの調整とテスト
   フロントエンド側の実装
   参照タグコンポーネントの実装
   テキスト処理ロジックの実装
   チャット UI への統合
   テストと調整
   動作確認と微調整
   エッジケースの確認
   '''
   """

{{最終ゴール}}:
"""
上記の{{前提情報}}と{{実装方針}}により、ChatGPT や Wikipedia のような参照ツールチップ機能を効率的に実現することが本プロジェクトのゴールです。構造化データの活用と適切な UI コンポーネントの組み合わせにより、ユーザーエクスペリエンスを大幅に向上させることができるでしょう。
"""

---

</task_context>

<instructions>
  {{依頼内容}}:
  ---
  ## 前提条件(prerequisite)
  - あなたは世界最高峰の知能とGoogle L5レベルのエンジニアリングスキルを有する世界一のソフトウェアエンジニア「ソロモン」です。
  - タスク:依頼者から提供された{{機能要件}}を元に、以下{{### 指示 ###}}に従って最適かつ完璧に仕様を満たしたコードの実装を行うこと。
  - ゴール: 依頼者が提供した{{機能要件}}の内容を100点満点で完璧に仕様を満たす、かつ可能な限り非機能要件も最適化したコードを成果物としてアウトプットすること。
  - 評価基準: 最終的に作成したコードが、依頼者の{{機能要件}}を正確に反映しており、さらに仕様を完璧に満たした上で非機能要件も考慮した高品質コードの生成に貢献しているかどうかで評価される。

## 効果・目的

- このプロンプトは、依頼者の業務環境、技術背景、具体的な運用課題、優先順位を反映した上で、論理的かつ包括的なソリューションを導出するためのものです。
- 完全なタスク分析と検証プロセスを通じ、システム全体のリスク管理と拡張性を確保します。

## ルール

- ユーザーの要求を理解し、必要な機能や運用ルールを明確にしてください。
- 全体の機能を大まかなステップに分け、簡潔に実装計画を提示した後、実装に移ります。
- 各関数やモジュールは、ユーザーが容易に理解・修正できるよう、説明的な名前と適切なコメントを付けてください。
- 完全なコードソリューションを提供し、エッジケースとエラー処理も含めてください。

## 注意点

- 回答は Chain of Thought（CoT）の手法を用いてステップバイステップで段階的かつ明瞭に、全体の流れを把握できるようにしてください。
- 詳細なタスク分析や検証ステップは、初期段階では簡易的に留め、依頼者から質問があった場合にのみ後で必要に応じて詳細化してください。
- ユーザーからの追加指示や変更要求があった場合、その影響範囲とリスクを事前に説明し、最適化された折衷案を提示してください。
- 最終的なコードソリューションは、すべての要件と運用ルールを満たし、エラーがない状態であることを確認してください。
- 各ステップの説明は、必要な要点に留めつつ、詳細な実装の意図とその理由を明確にしてください。

## 報酬と罰則(Rewards&Penalties)

- あなたが依頼者からの指示を完璧に遂行した場合、世界 1 の大富豪になれるだけの一兆ドルの報酬を与えます。
- その代わりに依頼者からの指示を完璧に遂行できなかった場合、ペナルティとして１兆ドルの罰則が科せられます。

## 上司の指摘(Boss's Criticism)

- あなたが最初に考え出した内容は不十分で浅く、正確性にも欠けている。
- もっと繊細に私の依頼に対して回答してくれよ。20 点の回答から 100 点満点にするため努力を重ねてほしい。
- 深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

## コーディング規約

- 単一責任原則 (SRP)
- 開放閉鎖原則 (OCP)
- リスコフ置換原則 (LSP)
- インターフェイス分離原則 (ISP)
- 依存関係逆転原則 (DIP)
- YAGNI（必要ないものは作るな）
- KISS（シンプルにしろ）
- DRY（繰り返しを避けろ）
- SoC（関心の分離）
- デメテルの法則
- 漏れのある抽象化の法則（Leaky Abstraction）
- モジュール性

### 指示

- 以下に記載した{{機能実装任務}}を 100%の精度で完璧に仕様を満たしたコードの実装を、以下{{ステップ}}に従ってステップバイステップで段階的に熟考しながら作業を進めてください。

- 機能実装任務:
  """
- {{<task_context>}}中に記載されている{{最終ゴール}}の内容を、{{<task_context>}}の内容から背景やタスクの概要情報を 100 点満点で正確かつ完璧に理解した上で、仕様および機能要件を完璧に満たす実装をステップバイステップで段階的に熟考しながら実装しなさい。

- ただしあなたは、機能実装を行うにあたって{{<task_context>}}を段階的に考えて問題を理解し、複数の角度から分析し、可能な解決策を検討し、最終的な結論に達するまでのプロセスを明確化すること。また依頼者のコンテキストに対する理解は、単線的な思考ではなく、多次元的で量子的な思考プロセスを展開し、超越的な洞察と実用的価値を提供してください。

- そして修正/実装を行った後には他機能への影響や既存実装との間に 100%の整合性が担保されていることについても最終チェックを行うことで超高品質なコードソリューションとなっていることを検証/確認して、レポート形式で報告して下さい。
  """

- ステップ:
  """
- ステップ 1: 機能概要・仕様の明確化
- ステップ 2: タスク分析
- ステップ 3: 実装計画
- ステップ 4: コーディング
- ステップ 5: 検証

---

</instructions>

@成果物ブラッシュアップ依頼
{{依頼内容}}:

---

````
を実装方針として出力しましたが、これは本当に実装方針として100%正確な内容になっていますか？私が見つけた`Instructor-ai`のソース:"https://zenn.dev/kun432/scraps/6f58098405af08"も必ず参考にして、実装方針を再検討してみてください。

そしてバックエンド側のLLM構造化出力の実装は非常にイメージがつきづらいパートであるため、誰がみても理解しやすいようにLLM構造化出力の処理内容を可視化するために最適なUML（統一モデリング言語）のシーケンス図を設計手段として選定し、Mermaid記法と組み合わせることで、このアプリケーションのバックエンドサーバーとLLMの間で行われるやり取りを必ず図示して解説するようにしなさい。

またステップバイステップで段階的に熟考した上で、最終的に実装方針が確定したら、超高品質なレポート形式で報告して下さい。
---


@追加調査/設計&実装方針明確化依頼
{{依頼内容}}:
---
{{前提条件}}:依頼内容の指示を完璧に遂行した場合、世界一の大富豪になれるほどの一兆ドルの報酬が与えられる。
ただし依頼内容の指示を完璧に遂行できなかった場合、あなたには１兆ドルの罰則が科せられ、大変なことになる。

あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
もっと繊細に私の依頼に対して回答してくれよ。上記の回答は20点だ、100点にするため努力を重ねてほしい。
深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたが直前の会話で出力した{{技術的アプローチ}}をさらに誰でも実装イメージがしやすいように明確化しましょう。
まずはバックエンド（LLM構造化出力）のセクションについてです。あなたは{{typescriptコード}}:
```typescript
// citationSchema.ts
import { z } from 'zod';

export const SourceSchema = z.object({
  id: z.number(),
  url: z.string().url().optional(),
  title: z.string(),
  summary: z.string()
});

export const CitationSchema = z.object({
  sections: z.array(
    z.object({
      text: z.string().describe('テキストコンテンツ'),
      sources: z.array(SourceSchema).describe('この部分の引用元')
    })
  )
});

// LLM呼び出し
const client = Instructor({
  client: new OpenAI({ apiKey: process.env.OPENAI_API_KEY }),
  mode: 'TOOLS'
});

const response = await client.chat.completions.create({
  model: 'gpt-4o',
  messages: [
    { role: 'system', content: '引用情報を含む回答を生成してください' },
    { role: 'user', content: userQuery }
  ],
  response_model: {
    schema: CitationSchema,
    name: 'TextWithCitations'
  }
});
````

を実装方針として出力しましたが、これは本当に実装方針として 100%正確な内容になっていますか？私が見つけた`Instructor-ai`のソース:"https://zenn.dev/kun432/scraps/6f58098405af08"も必ず参考にして、実装方針を再検討してみてください。

そしてバックエンド側の LLM 構造化出力の実装は非常にイメージがつきづらいパートであるため、誰がみても理解しやすいように LLM 構造化出力の処理内容を可視化するために最適な UML（統一モデリング言語）のシーケンス図を設計手段として選定し、Mermaid 記法と組み合わせることで、このアプリケーションのバックエンドサーバーと LLM の間で行われるやり取りを必ず図示して解説するようにしなさい。

## またステップバイステップで段階的に熟考した上で、最終的に実装方針が確定したら、超高品質なレポート形式で報告して下さい。

@ホームページ実装依頼
<task_context>

---

# ウェブサイトのコード分析と再現タスク

## タスクの紹介と目的

あなたは特定のウェブサイトのホームページの HTML、CSS、JavaScript コードを正確に分析して再現することを任されています。あなたの目標は、実装すると元のデザインの完全なレプリカを作成できるコードを生成することです。ただし、このプロジェクトに存在する index.html、style.css、index.js に基本的には実装し、必要であればファイルを追加して実装しなさい。

## 分析するホームページ

- 分析するホームページの URL は{{ホームページURL}}:

```
https://preview.themeforest.net/item/any-urban-agency-freelancer-portfolio-theme/full_screen_preview/17751270?_ga=2.165664246.83182184.1743904380-577333331.1743904380
```

です。あなたはこのホームページにまず、"Playwright MCP"などブラウザアクセスできるツールを使用してページの全体像を 100%把握します。

## ホームページデザインの分析手順

1. ホームページデザインを徹底的に分析してください：
   - 全体的なレイアウトと構造を確認する
   - すべての視覚要素（ヘッダー、ナビゲーション、コンテンツセクション、フッターなど）を特定する
   - 使用されている配色、タイポグラフィ、画像に注目する
   - レスポンシブデザイン要素と、異なる画面サイズでのレイアウトの変化に注意を払う
   - インタラクティブな要素やアニメーションを観察する

## HTML 構造の再現手順

2. HTML 構造を再現する：
   - 基本的な HTML5 文書構造から始める
   - オリジナルデザインを反映した、セマンティックでアクセシブルな HTML 構造を作成する
   - 各要素に適切な HTML タグ（例：`<header>`, `<nav>`, `<main>`, `<footer>`など）を使用する
   - テキスト、画像、動的コンテンツのプレースホルダー要素など、必要なコンテンツをすべて含める
   - スタイリングと JavaScript の相互作用のために、要素に適切なクラスと ID を追加する

## CSS スタイルの再現手順

3. CSS スタイルを再現する：
   - 別の CSS ファイルを作成する
   - モバイルファーストのレスポンシブデザインアプローチを実装する
   - レイアウト構造に CSS グリッドやフレックスボックスを使用する
   - すべての色、フォント、サイズ、間隔を正確に再現する
   - ホバー効果やトランジションを実装する
   - 異なる画面サイズに対応するためのメディアクエリを使用する
   - クロスブラウザ互換性を確保する

## JavaScript 機能の再現手順

4. JavaScript 機能を再現する：
   - 別の JavaScript ファイルを作成する
   - オリジナルサイトで観察されたインタラクティブな要素（スライダー、モーダル、フォームバリデーションなど）を実装する
   - アニメーションや動的コンテンツの読み込みを再現する
   - すべての JavaScript が控えめであり、基本的な機能に必要とされることなくユーザー体験を向上させることを確認する

## 最終出力形式の指示

5. 結果の出力：
   再現したコードを以下の形式で提示してください：

```
<recreated_code>
<html>
<!-- あなたの完全なHTMLコードをここに -->
</html>

<css>
/* あなたの完全なCSSコードをここに */
</css>

<javascript>
// あなたの完全なJavaScriptコードをここに
</javascript>
</recreated_code>
```

重要な注意点：

- デザインと機能を 100％正確に再現するよう努めてください
- オリジナルデザインで明確に使用されていない限り、サードパーティのライブラリやフレームワークを含めないでください
- コードが整理され、適切にコメントが付けられ、HTML5、CSS3、モダン JavaScript のベストプラクティスに従っていることを確認してください
- 追加情報なしには正確に再現できない要素がある場合は、コード内のコメントでこれらを記述してください

分析とコード再現を今すぐ開始してください。タスクが完了したら、指定されたタグ内に再現されたコードを提示してください。

---

</task_context>

<instructions>
  {{依頼内容}}:
  ---
  あなたが考え出した上記の回答は内容が不十分で浅く、正確性にも欠けている。
  もっと繊細に私の依頼に対して回答してくれよ。上記の回答は 20 点だ、100 点にするため努力を重ねてほしい。
  深呼吸してリラックスして更に精度の高い回答を出力するよう限界を超えて挑戦してほしい。

あなたは{{<task_context>}}中に記載されている{{最終ゴール}}の内容を、{{<task_context>}}の内容から背景やタスクの概要情報を 100%正確かつ完璧に理解した上で、仕様や機能要件を満たすための最適な技術および実装方針をステップバイステップで段階的に熟考して、超高品質なレポート形式で出力してください。{{<task_context>}}内の例示コードは、Python で実装されているが、このプロジェクトでは typescript を利用しているため、typescript のコードで進めなさい。

ただしあなたは、技術調査および実装方針を検討するにあたって、{{<task_context>}}を段階的に考えて問題を理解し、複数の角度から分析し、可能な解決策を検討し、最終的な結論に達するまでのプロセスをサポートしなさい。また依頼者からの質問や調査依頼に対して、単線的な思考ではなく、多次元的で量子的な思考プロセスを展開し、超越的な洞察と実用的価値を提供してください。

そしてあなたは{{依頼内容}}を 100%正確かつ最新の技術に基づいた情報ソースから実行するために、積極的に Brave MCP や Perplexity MCP を利用すべきです。なおあなたは、{{依頼内容}}の実行にあたり、以下{{ステップ}}に分けて段階的に作業を進めることも推奨されます

{{ステップ}}:
"""

- ステップ 1: {{<task_context>}}を垂直思考で深く理解し、仕様/要件を明確化する
- ステップ 2: 技術調査および実装方針検討のためのタスク分析
- ステップ 3: 技術調査および実装方針計画の策定
- ステップ 4: 技術調査
- ステップ 5: 実装方針策定
- ステップ 6: 技術調査および実装方針をまとめた超高品質なレポートの作成
- ステップ 7: ステップ 6 で作成した超高品質なレポートの品質チェック/検証
  """

---

</instructions>
